در دنیای برنامه‌نویسی، ارتباط بین اشیاء مختلف یک چالش همیشگی است. تصور کنید یک سیستم دارید که در آن چندین جزء باید از
تغییرات در یک جزء خاص آگاه شوند. برای مثال، در یک برنامه آب و هوا، چندین اپلیکیشن موبایل باید به محض تغییر وضعیت آب و
هوا به‌روزرسانی شوند. یا در یک بازی آنلاین، تمام کاربران باید از حرکت‌های دیگر بازیکنان مطلع شوند.

## دیزاین‌پترن Observer

الگوی _Observer_ در دسته الگوهای رفتاری (_Behavioral_) قرار دارد. این الگو به ما اجازه می‌دهد مکانیزمی تعریف کنیم تا
چندین شئ را وقتی رویدادی برای یک شئ خاص رخ می‌دهد، خبردار کنیم.

### مشکل

فرض کنید شما در اینستاگرام هستید و در حال مرور پست‌ها و ریلز‌های مختلف. وقتی یک ویدیو جالب می‌بینید، تصمیم می‌گیرید آن
را برای دوست خود بفرستید. حالا سوال اینجاست که اینستاگرام چگونه دوست شما را از اینکه شما برایش پیامی ارسال کردید مطلع
می‌کند؟

اگر اینستاگرام به روش سنتی عمل کند، اینستاگرام دوست شما باید هر چند لحظه یک بار درخواست‌هایی به سرور ارسال کند تا بررسی
کند آیا پیام جدیدی وجود دارد یا خیر. حال فرض کنید اینستاگرام میلیون‌ها کاربر داشته باشد و همگی آنها همواره بخواهند از
وجود پیام جدید در دایرکتشان آگاه شوند.
با روش قدیمی و حجم بسیار بالای درخواست‌ها به سرور اینستاگرام برای مطلع شدن از وجود پیام جدید، می‌تواند به ترافیک بالای
سرورها و بهینه نبودن سیستم منجر شود.
و همینطور به دلیل زمان‌بندی درخواست‌ها، ممکن است پیام‌ها با تأخیر به دست کاربران برسند و یا حتی بعضی از آنها هرگز به
مقصد نرسند.

### راه حل

برای حل این مشکل و بهبود عملکرد سیستم، از دیزاین پترن _Observer_ استفاده می‌شود.
در این دیزاین‌پترن، ما دو کلاس کلیدی داریم:

1. شیء که حالت جالبی دارد، اغلب _Subject_ نامیده می‌شود، اما از آنجا که قرار است دیگر اشیاء را از تغییرات حالت خود مطلع
   سازد، ما آن را _Publisher_ می‌نامیم. در مثال بالا پابلیشر همان اینستاگرام است.
2. کلاسی به عنوان شنونده که وظیفه گوش‌دادن به _Publisher_ را دارد. که در مثال بالا همان کاربران ایسنتاگرام هستند.

در این برنامه، _Publisher_ ما یک کانال است که با فرستاده شدن یک پیام در این کانال، بقیه اعضای آن یا همان _Observer‌های_
ما، می‌توانند آن پیام را دریافت کنند. بنابراین هر _Publisher،_ باید اطلاعی از _Observer‌های_ خود داشته باشد تا با آپدیت
شدن وضعیت آن، بتواند به آن‌ها اطلاع دهد.

### نحوه پیاده سازی

```Python
class Observer:
    def update(self, message):
        pass


class Channel:
    def __init__(self):
        self.observers = []

    def add_observer(self, observer):
        self.observers.append(observer)

    def send_message(self, message):
        for observer in self.observers:
            observer.update(message)


class User(Observer):
    def __init__(self, name):
        self.name = name

    def update(self, message):
        print(f"{self.name} received: {message}")


if __name__ == "__main__":
    chat_channel = Channel()
    user1 = User("Ali")
    user2 = User("Reza")

    chat_channel.add_observer(user1)
    chat_channel.add_observer(user2)

    chat_channel.send_message("Hello everyone!")

```


1. **کلاس Observer:**

    - این کلاس یک اینترفیس برای تمام ناظرها تعریف می‌کند. متد `update` برای دریافت پیام‌ها توسط ناظرهاست.

2. **کلاس Channel:**

    - **`__init__`**: در این متد، یک لیست خالی به نام `observers` برای ذخیره ناظرها ایجاد می‌شود.
    - **`add_observer`**: این متد یک ناظر جدید را به لیست ناظرها اضافه می‌کند.
    - **`send_message`**: این متد یک پیام دریافت می‌کند و آن را به تمام ناظرهای موجود در لیست `observers` ارسال می‌کند.

3. **کلاس User:**

    - این کلاس از کلاس `Observer` ارث‌بری می‌کند و نشان‌دهنده یک ناظر است.
    - **`__init__`**: در این متد سازنده، نام کاربر تنظیم می‌شود.
    - **`update`**: این متد زمانی که پیام جدیدی دریافت می‌شود، پیام را چاپ می‌کند.

4. **اجرای کد:**
    - در این بخش، یک کانال چت (`chat_channel`) ایجاد می‌کنیم.
    - دو کاربر (`user1` و `user2`) با نام‌های "Ali" و "Reza" ساخته را ایجاد می‌کنیم.

```python
if __name__ == "__main__":
    chat_channel = Channel()
    user1 = User("Ali")
    user2 = User("Reza")

    chat_channel.add_observer(user1)
    chat_channel.add_observer(user2)

    chat_channel.send_message("Hello everyone!")
```


- این دو کاربر به عنوان ناظر یا _observer_ به کانال چت اضافه می‌شوند. تا هر موقع که در کانال پیامی ارسال شود از این
  اتفاق آگاه شوند.
- سپس، یک پیام `"Hello everyone!"` به همه ناظرها (کاربران) ارسال می‌شود.

### خروجی:

```plaintext
Ali received: Hello everyone!
Reza received: Hello everyone!
```


### مزایای استفاده از پترن _Observer_

- جلوگیری از ایجاد تغییر روی _Observerها_: کلاس _Subject_ با _Observerهای_ خود ارتباط کمی دارند بنابراین تغییرات روی
  کلاس _Subject_ اثری روی کلاس _Observer_ نخواهد گذاشت.
- ارسال یک پیام _BroadCast_: با استفاده از این پترن میتوانیم یک پیام را به تمام _observerها_ ارسال کنیم.
- افزایش _Maintainability_: وجود نداشتن _Coupling_ یا پیوستگی بین _Subject_ و _Observers_ باعث افزایش توسعه‌پذیری (
  _Maintainability_) می‌شود.

### معایب استفاده از پترن _Observer_

- ایجاد _Memory Leaks_: به دلیل اضافه شدن _Observerها_ به لیست و عدم حذف آن‌ها، ممکن است _Observerهایی_ غیر ضروری در
  لیست قرار گرفته باشند و باعث مشکلات حافظه‌ای شوند.
- به‌وجود آمدن سربار (_Overhead_) ناخواسته: به‌ دلیل وجود لیست _Observer_ در کلاس _Subject_ با افزایش تعداد آن‌ها، ممکن
  است _Overhead_ ایجاد شود.